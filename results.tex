\chapter{Results}
\label{chap: results}

% TABLE
\begin{table}
\resizebox{\columnwidth}{!}{%
\begin{tabular}{|l|rr|rr|r||rr|rr|r||rr|rr|r|}
\hline
 & \multicolumn{15}{c|}{ \#S }\\
\hline
\#Solutions & \multicolumn{5}{c||}{ k=2 } & \multicolumn{5}{c||}{ k=4 } & \multicolumn{5}{c|}{ k=8 }\\
\hline
Transitivity & \multicolumn{2}{c|}{ St } & \multicolumn{2}{c|}{ L } & \multicolumn{1}{c||}{ \#N }
& \multicolumn{2}{c|}{ St } & \multicolumn{2}{c|}{ L } & \multicolumn{1}{c||}{ \#N } 
& \multicolumn{2}{c|}{ St } & \multicolumn{2}{c|}{ L } & \multicolumn{1}{c|}{ \#N }\\
\hline
Compatibility & \multicolumn{1}{c}{F} & \multicolumn{1}{c}{S} & \multicolumn{1}{c}{F} & \multicolumn{1}{c|}{S} &
\multicolumn{1}{c||}{-} & 
\multicolumn{1}{c}{F} & \multicolumn{1}{c}{S} & \multicolumn{1}{c}{F} & \multicolumn{1}{c|}{S} &
\multicolumn{1}{c||}{-} & 
\multicolumn{1}{c}{F} & \multicolumn{1}{c}{S} & \multicolumn{1}{c}{F} & \multicolumn{1}{c|}{S} &
\multicolumn{1}{c|}{-}\\ 
\hline
crewplanning(30) & 5 & 5 & 5 & 5 & 25 & 5 & 5 & 5 & 5 & 25 & 2 & 0 & 3 & 1 & 22 \\ 
parking(10) & 8 & 8 & 8 & 8 & 9 & 9 & 9 & 9 & 9 & 9 & 6 & 6 & 6 & 6 & 6 \\ 
quantum circuit(10) & 5 & 5 & 5 & 5 & 8 & 5 & 5 & 5 & 5 & 6 & 5 & 5 & 5 & 5 & 5 \\
trucks(10) & 8 & 8 & 8 & 8 & 10 & 10 & 9 & 10 & 10 & 10 & 8 & 8 & 9 & 9 & 10 \\ 
turn and open(20) & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 0 & 0 & 1 & 0 & 1 \\ 
\hline
Total  & 28 & 28 & 28 & 28 & 54 & 30 & 29 & 30 & 30 & 51 & 21 & 19 & 24 & 21 & 44\\
\hline
\end{tabular}
}
\caption{Empirical results table: Success Counts}
\label{table: results - success}
\end{table}

\begin{table}
\resizebox{\columnwidth}{!}{%
\begin{tabular}{|l|rr|rr|r||rr|rr|r||rr|rr|r|}
\hline
    & \multicolumn{15}{c|}{Compactness}\\
\hline
\#Solutions & \multicolumn{5}{c||}{ k=2 } & \multicolumn{5}{c||}{ k=4 } & \multicolumn{5}{c|}{ k=8 }\\
\hline
Transitivity &  \multicolumn{2}{c|}{ St } & \multicolumn{2}{c|}{ L } & \multicolumn{1}{c||}{ \#P } 
& \multicolumn{2}{c|}{ St } & \multicolumn{2}{c|}{ L } & \multicolumn{1}{c||}{ \#P }
& \multicolumn{2}{c|}{ St } & \multicolumn{2}{c|}{ L } & \multicolumn{1}{c|}{ \#P }\\
\hline
Compatibility & \multicolumn{1}{c}{F} & \multicolumn{1}{c}{S} & \multicolumn{1}{c}{F} & \multicolumn{1}{c|}{S} &
\multicolumn{1}{c||}{-} & 
\multicolumn{1}{c}{F} & \multicolumn{1}{c}{S} & \multicolumn{1}{c}{F} & \multicolumn{1}{c|}{S} &
\multicolumn{1}{c||}{-} & 
\multicolumn{1}{c}{F} & \multicolumn{1}{c}{S} & \multicolumn{1}{c}{F} & \multicolumn{1}{c|}{S} &
\multicolumn{1}{c|}{-}\\ 
\hline
crewplanning(30) & 0.017 & 0.116 & 0.017 & 0.113 & 5 & 0.185 & 0.175 & 0.185 & 0.178 & 5 & - & - & - & - & 0 \\
parking(10) & 0.042 & 0.042 & 0.042 & 0.042 & 8 & 0.09 & 0.098 & 0.09 & 0.098 & 9 & 0.117 & 0.122 & 0.102 & 0.111 & 6\\
quantum circuit(10) &  0.035 & 0.035 & 0.035 & 0.035 & 5 & 0.072 & 0.072 & 0.072 & 0.079 & 5 & 0.131 & 0.126 & 0.066 & 0.075 & 5\\
trucks(10) &0.05 & 0.081 & 0.05 & 0.077 & 8 & 0.059 & 0.063 & 0.056 & 0.058 & 9 & 0.066 & 0.048 & 0.032 & 0.023 & 8 \\
turn and open(20) & 0.03 & 0.057 & 0.03 & 0.065 & 2 & 0.16 & 0.043 & 0.014 & 0.02 & 1 & - & - & - & - & 0 \\
\hline
Average & 0.035 & 0.066 & 0.035 & 0.066 & 28 & 0.113 & 0.09 & 0.083 & 0.087 & 29 & 0.105 & 0.099 &	0.067 &	0.07 & 19\\ 
\hline
\end{tabular}
}
\caption{Empirical results table: Compactness Scores}
\label{table: results - compactness}
\end{table}



\section{Empirical Evaluation}
In order to empirically evaluate our algorithm, our compilation takes a temporal planning task $\Pi$ and generates a set of $k$ diverse solutions using the plan elimination compilation described in Section 4, with OPTIC \cite{benton2012temporal} as the underlying solver. The TPS of each solution is obtained and $\MergeSet$ is computed, containing all the compatible time point pairs found in the naive TPN.
We then construct a COP based on $\MergeSet$ in Minizinc \cite{nethercote2007minizinc} and use Gecode \cite{gecode} to solve it. As output, we receive a mapping from time point pairs to merge operations resulting in a new TPN.
%which has been optimized for compactness. 
If no compatible pairs are found (i.e. $\MergeSet = \emptyset$) the naive TPN is returned as output. 


We evaluated all combinations of $k$ chosen from $\{2,4,8\}$, and both compatibility methods 
(Full \& Semi denoted as F,S) and merging transitivity (Strict \& Loose denoted as St,L). Thus, for each problem, we ran the diverse planner 3 times (for the different values of $k$), and then ran 4 different versions of our COP (for the different compatibility and transitivity). The experiments were performed on Intel i7-7700K 32GB RAM, with a time limit of 30min for generating the diverse solutions and 5min for the COP task.
Surpassing the 30min time limit for obtaining diverse solutions results in a failed run, while surpassing the 5min limit on the COP results in the best solution found so far (i.e. not proven to be an optimal solution) or the naive TPN if no solution at all was found in this time.
 


We evaluated our approach on all domains from the temporal track IPC in 2011, 2014, and 2018. Of these, we eliminated domains with actions whose durations depend on the current state, as this is not supported in a TPN.
Out of these, we kept the domains where OPTIC was able to retrieve multiple diverse solutions for more than a single problem.

We define a run on a specific problem to be successful if: \textit{i)} OPTIC is able to obtain $k$
diverse solutions to the problem and \textit{ii)} the generated TPN is more compact than the naive TPN.
Otherwise, although the algorithm might have terminated successfully, we do not count it.
Such a scenario occurs when the generated solutions in $\Pi$ are very different from one another 
and no compatible pairs are found between them, leading to no possible merges to the naive TPN.
Table \ref{table: results - success} showcases the number of problems for which we were
able to obtain $k$ solutions as \#N, and the number of successful runs as \#S.

Table \ref{table: results - compactness} reports by how much our approach was able to reduce the size 
of the naive TPN. As different values of $k$ for the same problem lead to different sizes of the naive TPN, 
we evaluate the compactness of the generated TPN relative to the size of the naive 
TPN: $compactness(TPN) = 1 - \frac{|\mathcal{E}_{new}|}{|\mathcal{E}_{naive}|}$. 
We show the average compactness over the commonly solved problems for each $k$ by the four different 
configurations of our approach. \#P denotes the number of commonly solved problems for each $k$.

% In addition, though not detailed in this paper, our process encapsulates the possibility of accepting as input a Classical Planning instance along with a specification for each of the domain actions' duration. Given these, our process too can generate a TPN. The significance of this additional option is that from a simple classical PDDL model, the path to generating a Temporal Planning Network complete with valid solutions and schedules becomes very brief.
% The classical implementation makes use of a top-$k$ planner \cite{katz2018novel} for obtaining the diverse solutions.

% As demonstrated earlier, selecting the ``best'' TPN is a multi-objective optimization problem.
% Although we have chosen to capitalize on the size of the output TPN, we report the values of the valid plans measure as well. This way, we hope to allow the empirical results to help users choose their desired objective according to their specific goals.


%\subsection{IPC Benchmarks}



%\paragraph{Comparison Table} The following table (\ref{table: table}) displays, on the left, the normalized Compactness of the TPNs, based on $k$, 

%The number of problems averaged over for each domain is stated in column {\em P}.

%On the right hand side we showcase the number of {\em Successes} our algorithm achieved in finding compact TPNs. This success count is similar to coverage but differs in the following ways. 



%We display in column {\em \#} the number of problems for which OPTIC was able to obtain $k$ diverse solutions out of the whole problem set.

%\subsection{Results}

Before we analyze the results, we note that the larger $k$ is, the more IHs we have to compare between diverse solutions.
Therefore we expect that an increase in $k$ will result in more compatible pairs and thus in more merges and better compactness, but at the cost of more computational effort. 

\section{Results Discussion}
As the results in supplied tables show, the above intuition is partially correct. 
First, as the intuition suggests, for larger $k$ the number of successes decreases. This can be explained by the rise in complexity of the COP due to many compatible pairs and the associated high memory consumption.
However, on the other extreme, when $k$ is low there is a greater probability that the few diverse solutions generated will differ significantly from one another. Such instances may lead to either a low number of compatible pairs -- less merges and a worse compactness {\em or} finding no compatible pairs all together and resulting in an unsuccessful run. Indeed, this is what happened in the parking and trucks domains, where using $k=4$ resulted in more success than either $k=2$ or $k=8$.


We now turn out attention to examining the differences between the four configurations of our approach. First, note that using semi-compatibility always results in at least as many compatible pairs as using full-compatibility. 
This increase in the number of possibilities leads to an increase in the difficulty of solving the COP, which explains the higher success count of the full-compatibility, as can be seen in crewplanning for $k=8$ and truck for $k=4$.

On the other hand, the extra possibilities allow for more merges, and thus for better compactness. This is especially evident for $k=2$, where a single merge contributes more to the compactness than for higher values of $k$, since it involves time points from a higher proportion of the original solutions. 



Comparing using strict transitivity to loose transitivity, the former is applies stricter constraints, thus pruning the space of possible solutions. With lower values of $k$, this pruning makes little difference, implying that the best solutions are not typically pruned by this. With higher values of $k$ this pruning reduces the size of the search space, allowing the solver to find better solutions in the allotted time, at the cost of a slight reduction in the success count. 


% As can be expected, the more diverse plans we wish to generate the harder the task becomes and the coverage rate drops with the increase in $k$.  

% {\bf Comparing $k$s:}
% The higher the $k$, the more IHs we have to compare between diverse solutions. given that there exists a pattern as to how to solve a given problem, we can expect that multiple TPSs, although diverse, will make use of similar sequences of IHs along the way. Therefore raising the number of $k$ should bring about a rise in the number of compatible pairs of IHs between solutions and as a result increase the number of merges in the output TPN, thus raising the compactness score as $k$ grows. 